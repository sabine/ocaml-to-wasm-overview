:toc:
:toclevels: 5


# Sketch of Flambda 2.0 Semantics

This is an attempt of creating a minimal, human-readable, mathematical representation of Flambda 2.0. I tried to shorten things to the point that it's possible to get an impression what is going on at a quick glance. Sometimes I had to come up with syntax, in order to keep things brief. This is very much in flux.

Anything that is not absolutely required for stating the semantics is omitted (i.e. all kinds of debug and optimization-relevant info are left out here).

Purpose: resolve misunderstandings and improve my understanding of how Flambda 2.0 works. May serve as a draft for a formal semantics or an interpreter of Flambda 2.0.

# AST

## Basic Definitions

### Flambda Value

A Flambda value can be either

* An OCaml Value (Immediate or pointer to well-formed OCaml value) 
* Naked float (machine-width floating-point number)
* Naked immediate ((target_machine_width-1)-integer)
* there is more, all the naked stuff

### Variable

_variable_ ::= _id_

_variable_ is an identifier that refers to a Flambda value in the the value environment.


Note: a variable originates either in the source code or a it is introduced by the compiler.

Note: this corresponds to Ident.t in the toolchain before Flambda, like the type checker or Lambda.

Note: In the normal compilation chain, this is a cmm-variable, and a variable corresponds to a pseudo-register in the backend.

### Symbol

_symbol_ ::= _id_

_symbol_ is an identifier that refers to a statically-allocated OCaml value, but not an immediate.

Traditionally, the interpretation of a _symbol_ is the address of an object file symbol as described by the operating system specification. Symbols will never be read until they are completely initialized and once they are completely initialized, their contents will never change. 

NOTE: for performance reasons, it makes sense to statically allocate this in a way that it never moves.

### Register-width constant

A _reg_width_constant_ that fits in a register of the target machine we compile to.

* Tagged immediate
* Naked immediate
* Naked target-width integer (nativeint)
* Naked int32
* Naked int64
* Naked float

This is the same as an Flambda value, except for pointer to a well-formed OCaml value. This is because we refer to them by symbol names (see Simple).

### Simple

_simple_ ::= `Const` _reg_with_constant_ | `Variable` _variable_ 

Simple describes everything that can fit in a register, constant or non-constant. A major purpose of this is to avoid the necessity for let-bindings for register-width constants.

Note: Simple doesn't have any sub-expressions. There is nothing happening when interpreting this, except (in the case of variable), a lookup of the value in the environment, i.e. no beta-reduction going on here.

Q: It looks like the property that all simple variables that occur in the Flambda 2.0 program always have values that fit in a register is an invariant, and that this property comes from a higher compilation layer.

### Continuation

_continuation_ :== _id_

_continuation_ is an identifier that refers to a continuation handler in the environment.

Note: continuations are second class, i.e. they exist in the operational semantics, but they are not values. The definitions and uses of continuations are static, they do not change dynamically as the program runs.

### Kind

Kinds classify Flambda values. Kinds are second class in the sense that are assigned by the compiler, and never by the source program. An error with kinds is always a compiler bug, since all valid Lambda IR code must be assigned correct kinds by flambda. Note: the code does not need to pass the OCaml typechecker, as long as it is valid Lambda IR.

Kinds provide the essential information that the backend needs to know in order to decide what register or other thing to put a value in.

Note: In particular, this means that the compiler compiles operations on values of kind `Value` using only the information that the kind is `Value`. The fact that the value is a well-formed OCaml value is the only thing the compiler can rely on.

_flambda_kind_ ::= `Value` | `Naked_number`

_naked_number_kind_ ::= `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_or_float_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_boxable_number_ ::= `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint` | `Untagged_immediate`

### Primitive

_flambda_primitive_ ::=

* `Unary` _unary_primitive_ _simple_ |
* `Binary` _binary_primitive_ _simple_ _simple_ |
* `Ternary` _ternary_primitive_ _simple_ _simple_ _simple_ |
* `Variadic` _variadic_primitive_ _simple_* |

TODO: list primitives

Primitives perform various kinds of operations, e.g. allocation, loads, stores, arithmetic, etc. Some primitives depend on the environment (they have co-effects), some primitives affect the environment (they have effects), some do both, some do neither.

Primitives never perform control flow, they do not raise exception.

Note: Allocation cannot raise an OCaml exception. If allocation fails, that is a fatal error, unrecoverable, but not an OCaml exception!

TODO: look at the primitives list lambda.mli in detail. Bounds checks are primitives in Lambda IR. In the primitive conversion, from Lambda IR to Flambda, the checks are made explicit. Look at this and print out some examples of how the check is compiled to Flambda.

## Expressions

Expression _e_ ::=

* `Let` _bound_vars_ `=` _named_ `in` _e_  |
* `Let_symbol (` _scoping_rule_ `)` _bound_symbols_ `=` _static_const_ `in` _e_ |
* `Let_cont` [_continuation_ `=>` _continuation_handler_]* `in` _e_  |
* `Apply` _call_kind_ _callee_ `(` _simple_* `)` _continuation_ _exn_continuation_ |
* `Apply_cont` _continuation_ `(` _simple_* `)` _trap_action_ |
* `Switch` _scrutinee_ _arms_ |
* `Invalid`

### `Let`

_bound_vars_ ::=

* `Singleton` _var_in_binding_pos_ |
* `Set_of_closures` (_name_mode_, _closure_vars_)

_name_mode_ ::= `Normal` | `Phantom` | `In_types`

_var_in_binding_pos_ ::= _name_mode_ _variable_

_named_ ::=

* `Simple` _simple_
* `Prim` _flambda_primitive_
* `Set_of_closures` _set_of_closures_

### `Let_symbol`

_scoping_rule_ ::= `Syntactic` | `Dominator`

Q: does the scoping rule affect semantics, or can I omit this here?

_bound_symbols_ ::=

* `Singleton` _symbol_
* `Sets_of_closures (code_ids` _code_id_*, `closure_symbols` Map(_closure_id_ => _symbol_)`)`*

Q: Looking at https://github.com/ocaml-flambda/ocaml/blob/6ff563bcaa20d0e0ebecc689f9ed54baeba454b6/middle_end/flambda2.0/terms/let_symbol_expr.rec.ml#L22, I am confused: why is this a `Set` and not a list? How does this correspond to _code_and_set_of_closures_ below? I would expect that _bound_symbols_ defines essentially a list of symbols which are being bound, and that the value assigned to it is a list whose elements have both the function declaration _code_ (for which code is to be emitted), and the _set_of_closures_.
Q: why do we define set*s* of closures, instead of defining a single set of closures for every `Let_symbol` expression?

_static_const_ ::=

* `Block` _tag_ _mutable_or_immutable_ _field_of_block_* |
* `Sets_of_closures` _code_and_set_of_closures_* |
* `Boxed_float` [_B^64^_ | _variable_] |
* `Boxed_int32` [_B^32^_ | _variable_]  |
* `Boxed_int64` [_B^64^_ | _variable_]  |
* `Boxed_nativeint` [_targetint_ | _variable_]  |
* `Immutable_float_array` [_B^64^_ | _variable_]* |
* `Mutable_string` _string_ |
* `Immutable_string` _string_

_field_of_block_ ::=

* `Symbol` _symbol_ |
* `Tagged_immediate` _target_imm_ |
* `Dynamically_computed` _variable_


_code_and_set_of_closures_ ::= `(code` Map(_code_id_ => _code_) `,` `set_of_closures` _set_of_closures_ `)`

_code_ ::= `(` _continuation_, _exn_continuation_, _kinded_parameter_*, _e_, _flambda_arity_ `)`

Q: how are _code_ and _continuation_handler_ (from `Let_cont`) related? It seems that both have a list of parameters and a body. _code_ also has the arity of the return value, whereas continuation handlers, if I understand correctly, never return. (They always call another continuation in tail position.)

_set_of_closures_ ::= `(function_decls` _function_declarations_, `closure_elements` Map(_var_within_closure_ => _simple_) `)`

### `Let_cont`

_kinded_parameter_ ::= _variable_ : _flambda_kind_

_continuation_handler_ ::= `cont_handler (args` _kinded_parameter_* `, body` _e_ `)`

Q: can someone give me a code example where I can see a Flambda 2.0 come up with a `Let_cont` expression? So far, the code I came up with, I got only `Let_symbol` expressions with closures.

### `Apply`

_call_kind_ ::=

* `Function` _function_call_ |
* `Method` _method_kind_ `of` _simple |_
* `C_call` _alloc_ _param_arity_ _return_arity_

_method_kind_ ::= `Self` | `Public` | `Cached`

_alloc_ ::= B

_flambda_arity_ ::= _flambda_kind_*

_param_arity_ ::= _flambda_arity_

_return_arity_ ::= _flambda_arity_

_function_call_ ::=

* `Direct` _code_id_ _closure_id_ _return_arity_ |
* `Indirect_unknown_arity` |
* `Indirect_known_arity` _param_arity_ _return_arity_

_callee_ ::= _simple_

_exn_continuation_ ::= `exn_cont` _continuation_ `(` [_simple_ `=>` _flambda_kind_]* `)`

### `Apply_cont`

_raise_kind_option_ ::= `None` | `Some Regular` | `Some Reraise` | `Some No_trace`

_trap_action_ ::=

* `Push` _continuation_ |
* `Pop` _continuation_ _raise_kind_option_

### `Switch`

_scrutinee_ ::= _simple_

_arms_ ::= Map (_target_imm_ `=> Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ )

_target_imm_ ::= _targetint_


# Compilation unit

_C_ = {

* _imported_symbols_ : Map(_symbol_ -> _flambda_kind_),
* _return_continuation_ : _continuation_,
* _exn_continuation_ : _continuation_,
* _body_ : _e_}

This is what the Flambda 2.0 unit looks like. I assume that this corresponds 1:1 to an `.ml` file.

I assume that _return_continuation_ and _exn_continuation_ act as placeholders for the continuations provided by whoever calls the initialization function.

The _body_ of the compilation unit is the Flambda 2.0 expression that corresponds to all OCaml code of the file. So, this _body_ will likely define some global symbols and assign values to them.

To initialize the compilation unit at runtime, the _body_ is run with an environment that contains all the necessary information about the symbols imported from other files. That means, in order to initialize a compilation unit, all the other compilation units that it depends on must be initialized beforehand.

# Program State

## Basic Definitions

### Reference

Ref is the set of abstract references to the heap. We do not care how exactly they look like. We assume the presence of a garbage collector that manages these references (whether this is one we implement, or one that the host environment will provide, we do not distinguish on, at this point).

### Function Reference

FuncRef is the set of abstract references to functions. The point of this is to have a way to call a function.

On x86 this specializes to: a pointer into linear memory, pointing to the location of the machine instructions emitted for the function.

On WASM, this specializes to: a `funcref` or an index into a global function table that refers to the WASM function emitted for the original function.

### Heap Value

Here is an attempt to describe what a heap value from the POV of Flambda 2.0 looks like, in the most general sense:

HeapValue = {(x~1~, ..., x~n~) | x~i~ ∈ HeapField, n ∈ ℕ}

HeapField = {`Targetint` i | i ∈ _targetint_} ∪ {`FuncAddress` f | f ∈ FuncRef} ∪ {`Ref` r | r ∈ Ref}

I suppose that the target integers can or should be refined to all the different integer types of Flambda 2.0.

I don't know if this is sufficient to describe all the different heap blocks there are.

I have the suspicion, that it might make sense to make a more fine-grained model that takes into account the different kinds of tags that come with specific assumptions about the block. I'm holding off on that for now, though.

It seems that in Flambda 2.0, the closure representation does not contain the dreaded infix blocks anymore (which would have made the heap model more complex than this). Flambda has closure operations `Project_var` and `Select_closure`. Maybe, if this turns out to be useful, this can be used to add a more abstract representation of closures here. Maybe not.

### Value

A Value is either an integer that is one bit smaller than that of the target architecture, or a reference to the heap.

Value = {`Targetint` x | x ∈ B^architecture_int_size-1^} ∪ {`Ref` r | r ∈ Ref}

## Top-Level State

Environment = {

* _symbol_values_: _symbol_ ⇀ Value,
* _bound_variables_: _variable_  ⇀ Value,
* _continuations_ : _continuation_ ⇀ _continuation_handler_,
* _return_cont_: _continuation_,
* _exn_cont_: _continuation_,
* _current_body_ : _e_ }

Heap = Ref ⇀ HeapValue

The heap is a partial function from Ref to HeapValue.

Q: should there be anything else here?

TODO

# Semantics

## Initial State

Given a compilation unit _C_:

_env0_ (_C_) = {

* _symbol_values_ = ∅,
* _bound_variables_ = ∅,
* _continuations_ = ∅,
* _return_cont_ = _C.return_continuation_,
* _exn_cont_ = _C.exn_continuation_,
* _body_ = _C.body_ }

_heap_ = ∅ 

The initial heap is empty.

TODO: I need to somehow insert here the notion of the imported global symbols being available. Reason being that evaluation of imported global symbols depends on whatever their semantics is. I guess, this can go into _symbol_values_?

## Evaluating different things

All the different eval functions map an environment and some thing to the Value of that thing in the given environment.

_eval_simple_ _env_ _simple_ = TODO

_eval_primitive_ _env_ _flambda_primitive_ = TODO

_eval_set_of_closures_ _env_ _set_of_closures_ = TODO

### Evaluating _named_

_eval_named_ _env_ _named_ = _value_ 

where

a. _value_ = _eval_simple _env_ _simple_ *iff* _named_ = `Simple` _simple_
b. _value_ = _eval_primitive _env_ _flambda_primitive_ *iff* _named_ = `Prim` _flambda_primitive_
c. _value_ = _eval_set_of_closures_ _env_ _set_of_closures_ *iff* _named_ = `Set_of_closures` _set_of_closures_

## Step function

TODO: given an _env_ and a _heap_, define what _env'_ and _heap'_ look like.

Anything not mentioned about _env'_ is assumed to be the same as in _env_.

Let's look at the different cases of _env.body_:

### `Let`

1. _env.body_ =  `Let Singleton Phantom` _variable_ = _named_ `in` _e_
+
_env'.body_ = _e_
+
As far as I understand, a phantom variable could as well not exist, wrt to the semantics of the program.

2. _env.body_ =  `Let Singleton Normal` _variable_ = _named_ `in` _e_
+
_env'.bound_variables_[_variable_] = _eval_named_ _env_ _named_
+
_env'.body_ = _e_

3. _env.body_ =  `Let Singleton In_types` _variable_ = _named_ `in` _e_
+
TODO: I have no clue what In_types means, find out about that.
+
_env'.body_ = _e_

4. _env.body_ =  `Let Set_of_closures (Phantom,` _closure_vars_ `)` = `Set_of_closures` _set_of_closures_ `in` _e_
+
_env'.body_ = _e_

5. _env.body_ =  `Let Set_of_closures (Normal,` _closure_vars_ `)` = `Set_of_closures` _set_of_closures_ `in` _e_
+
TODO

6. _env.body_ =  `Let Set_of_closures(In_types,` _closure_vars_ `)` = `Set_of_closures` _set_of_closures_ `in` _e_
+
TODO



### `Let_symbol`

1. _env.body_ =  `Let_symbol (Syntactic) Singleton` _symbol_ `=` _static_const_ `in` _e_

TODO

_env'.body_ = _e_

2. _env.body_ =  `Let_symbol (Dominator) Singleton` _symbol_ `=` _static_const_ `in` _e_

TODO

_env'.body_ = _e_

3. _env.body_ =  `Let_symbol (Syntactic)` _sets_of_closures_ `=` _static_const_ `in` _e_

TODO

_env'.body_ = _e_

4. _env.body_ =  `Let_symbol (Dominator)` _sets_of_closures_ `=` _static_const_ `in` _e_

TODO

_env'.body_ = _e_

### `Let_cont`

_env.body_ = `Let_cont` _continuation_handlers_ `in` _e_

where _continuation_handlers[i] = _continuation_~i~ `=>` `cont_handler (args` _kinded_parameters_~i~ `, body` _body_~i~ `)` `in` _e_

For all _i_:

_env'.continuations[continuation_~i~_]_ = `cont_handler (args` _kinded_parameters_~i~ `, body` _body_~i~ `)`

_env'.body_ = _e_

### `Apply`

TODO

### `Apply_cont`

Let _env.body_ = `Apply_cont` _c_ `(` _args_ `)` _continuation_ _exception_continuation_

and let _env.continuations[c]_ = `cont_handler (args` _kinded_parameters_ `, body` _e_ `)`

Then,

_env'.bound_variables[kinded_parameters_~i~_.variable]_ = _env.bound_variables[args_~i~_]_

_env'.body_ = _e_

_env'.cont_ = _continuation_

_env'.exn_cont_ = _exception_continuation_

### `Switch`

Let _env.body_ = `Switch` _scrutinee_ _arms_

1. If _scrutinee_ = `Reg_width_constant` _imm_, then

_env'.body_ = _arms_[_imm_]

2. If _scrutinee_ = `Variable` _var_

and let _imm_ = _env.bound_variables[var]_  (Q: does this make sense, is the value of a simple variable always something that fits in a register?)

Then,

_env'.body_ = _arms_[_imm_]
